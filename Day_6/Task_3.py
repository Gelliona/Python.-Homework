"""
Задайте список из вещественных чисел. Напишите программу, которая найдёт
разницу между максимальным и минимальным значением дробной части элементов.
"""
from memory_profiler import profile
import math


'Первоначальный вариант'


@profile()
def my_func():
    my_list = [math.sqrt(el) for el in range(50000)]
    new_list = []
    for i in range(50000):
        new_list.append(round(my_list[i] - int(my_list[i]), 5))
    my_list = None

    if 0 in new_list:
        new_list.remove(0)

    total = round(max(new_list) - min(new_list), 5)
    new_list = None
    return total


'Вариант после анализа используемой памяти'


@profile()
def my_func2():
    generator = (math.sqrt(el) for el in range(50000))
    new_list2 = []
    for j in generator:
        new_list2.append(round(j - int(j), 5))

    if 0 in new_list2:
        new_list2.remove(0)

    total = round(max(new_list2) - min(new_list2), 5)
    new_list2 = None
    return total


print(f'Разница между максимальным и минимальным значениями - {my_func()}')
print(f'Разница между максимальным и минимальным значениями - {my_func2()}')

"""
При генерации списка my_list, а также при проходе по этому списку
и формировании из него нового списка new_list происходит значительный скачок
затрат оперативной памяти. Присвоив эти списки к None после выполнения
необходимых действий с ними, мне удалось освободить часть памяти,
но не удалось вернуть её значение к первоначальному. Тогда я заменила
List Comprehension на генератор. На его работу памяти выделяется немного
больше, но при дальнейшем обходе элементов генератора используется меньше
памяти, чем при обходе элементов списка. Таким образом, в функции остаётся
только один список new_list2, который я присваиваю к None после завершения
необходимых действий с ним. И в итоге используемая память полностью
возвращается к первоначальному значению. Однако стоит признать, что конечное
значение используемой памяти для обоих способов одинаково. При использовании
второго способа просто не происходит большого скачка затрат памяти во время
работы функции, благодаря использованию генератора.
"""